# .github/workflows/AutoMerge.yml
name: Auto-merge PRs & cleanup merged branches

on:
  workflow_dispatch:
    inputs:
      merge_method:
        description: "Merge method to use (squash/merge/rebase)"
        type: choice
        options: [squash, merge, rebase]
        default: squash
      include_drafts:
        description: "Include draft PRs"
        type: choice
        options: ["false", "true"]
        default: "false"
      dry_run:
        description: "Dry run (no merges / no deletions; logs only)"
        type: choice
        options: ["false", "true"]
        default: "true"
  schedule:
    - cron: "17 06 * * *"

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: automerge-cleanup
  cancel-in-progress: false

jobs:
  automerge_and_cleanup:
    runs-on: ubuntu-latest

    env:
      GH_TOKEN: ${{ github.token }}

      MERGE_METHOD: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.merge_method || 'squash' }}
      INCLUDE_DRAFTS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.include_drafts || 'false' }}
      DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run || 'false' }}

      KEEP_BRANCH_REGEX: '^(main|master|develop|dev|release|staging|production|gh-pages)$'
      RUN_REF: ${{ github.ref_name }}

    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Auto-merge all open PRs (enable auto-merge; fallback to immediate merge)
        shell: bash
        run: |
          set -euo pipefail

          case "${MERGE_METHOD}" in
            squash) merge_flag="--squash" ;;
            merge)  merge_flag="--merge" ;;
            rebase) merge_flag="--rebase" ;;
            *) echo "MERGE_METHOD must be squash|merge|rebase (got: ${MERGE_METHOD})" >&2; exit 1 ;;
          esac

          echo "Finding open PRs..."
          mapfile -t prs < <(gh pr list --state open --limit 200 --json number,isDraft --jq '.[] | "\(.number) \(.isDraft)"')

          if (( ${#prs[@]} == 0 )); then
            echo "No open PRs found."
            exit 0
          fi

          for row in "${prs[@]}"; do
            pr_number="${row%% *}"
            is_draft="${row##* }"

            if [[ "${INCLUDE_DRAFTS}" != "true" && "${is_draft}" == "true" ]]; then
              echo "Skipping draft PR #${pr_number}"
              continue
            fi

            echo "Processing PR #${pr_number} (method=${MERGE_METHOD}, dry_run=${DRY_RUN})"

            if [[ "${DRY_RUN}" == "true" ]]; then
              echo "DRY RUN: would run: gh pr merge ${pr_number} ${merge_flag} --auto --yes"
              echo "DRY RUN: (fallback if needed) gh pr merge ${pr_number} ${merge_flag} --yes"
              continue
            fi

            # Try to enable auto-merge first
            if output="$(gh pr merge "${pr_number}" ${merge_flag} --auto --yes 2>&1)"; then
              echo "${output}"
              continue
            else
              echo "${output}"
            fi

            # If auto-merge can't be enabled due to missing protected branch rules, fall back to immediate merge
            if echo "${output}" | grep -qi "Protected branch rules not configured for this branch"; then
              echo "Auto-merge cannot be enabled (branch protection rules not configured). Attempting immediate merge for PR #${pr_number}..."
              if ! gh pr merge "${pr_number}" ${merge_flag} --yes; then
                echo "WARN: Immediate merge also failed for PR #${pr_number} (may need approvals/checks/conflict resolution)."
              fi
            else
              echo "WARN: Could not enable auto-merge for PR #${pr_number} (conflicts, missing checks/reviews, restrictions, or other error)."
            fi
          done

      - name: "Cleanup: delete branches that are already merged"
        shell: bash
        run: |
          set -euo pipefail

          default_branch="$(gh api "repos/${GITHUB_REPOSITORY}" -q '.default_branch')"
          echo "Default branch: ${default_branch}"
          echo "Workflow running on ref: ${RUN_REF}"

          git fetch origin --prune --tags
          git fetch origin "+refs/heads/*:refs/remotes/origin/*" --prune

          mapfile -t branches < <(gh api "repos/${GITHUB_REPOSITORY}/branches" --paginate -q '.[].name')

          if (( ${#branches[@]} == 0 )); then
            echo "No branches returned by GitHub API."
            exit 0
          fi

          for branch in "${branches[@]}"; do
            # Never delete default branch
            if [[ "${branch}" == "${default_branch}" ]]; then
              continue
            fi

            # Safety: don't delete the branch we're running from
            if [[ "${branch}" == "${RUN_REF}" ]]; then
              echo "Keeping branch (current workflow ref): ${branch}"
              continue
            fi

            # Never delete kept/protected branches
            if [[ "${branch}" =~ ${KEEP_BRANCH_REGEX} ]]; then
              echo "Keeping branch (matches KEEP_BRANCH_REGEX): ${branch}"
              continue
            fi

            # Don't delete branches with open PRs (limit=1 is enough)
            open_prs="$(gh pr list --state open --head "${branch}" --limit 1 --json number --jq 'length' || echo 0)"
            if [[ "${open_prs}" != "0" ]]; then
              echo "Keeping branch (has open PR): ${branch}"
              continue
            fi

            merged_by_pr="0"
            merged_by_git="0"

            # Only treat as merged if it merged into the default branch (limit=1 is enough)
            merged_prs="$(gh pr list --state merged --head "${branch}" --base "${default_branch}" --limit 1 --json number --jq 'length' || echo 0)"
            if [[ "${merged_prs}" != "0" ]]; then
              merged_by_pr="1"
            fi

            # Git ancestry check (handles merge commits / direct merges)
            if git show-ref --verify --quiet "refs/remotes/origin/${branch}"; then
              if git merge-base --is-ancestor "origin/${branch}" "origin/${default_branch}"; then
                merged_by_git="1"
              fi
            fi

            if [[ "${merged_by_pr}" == "1" || "${merged_by_git}" == "1" ]]; then
              if [[ "${DRY_RUN}" == "true" ]]; then
                echo "DRY RUN: would delete merged branch: ${branch}"
              else
                echo "Deleting merged branch: ${branch}"
                git push origin --delete "${branch}" || echo "WARN: Failed to delete ${branch} (protected or already deleted)."
              fi
            else
              echo "Not deleting (not detected as merged into ${default_branch}): ${branch}"
            fi
          done
