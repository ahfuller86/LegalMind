# .github/workflows/AutoMerge.yml
name: Auto-merge PRs & cleanup merged branches

on:
  workflow_dispatch:
    inputs:
      merge_method:
        description: "Merge method to use (squash/merge/rebase)"
        type: choice
        options: [squash, merge, rebase]
        default: squash
      include_drafts:
        description: "Include draft PRs"
        type: choice
        options: ["false", "true"]
        default: "false"
      dry_run:
        description: "Dry run (no merges / no deletions; logs only)"
        type: choice
        options: ["false", "true"]
        default: "true"
      automerge_label:
        description: "Only process PRs with this label (recommended)"
        type: string
        default: "automerge"
  schedule:
    - cron: "17 06 * * *"

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: automerge-cleanup
  cancel-in-progress: false

jobs:
  automerge_and_cleanup:
    runs-on: ubuntu-latest

    env:
      GH_TOKEN: ${{ github.token }}

      # Inputs for workflow_dispatch, safe defaults for schedule.
      MERGE_METHOD: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.merge_method || 'squash' }}
      INCLUDE_DRAFTS: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.include_drafts || 'false' }}

      # Scheduled runs should be dry-run by default.
      DRY_RUN: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.dry_run || 'true' }}

      # Label gating to avoid merging everything.
      AUTOMERGE_LABEL: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.automerge_label || 'automerge' }}

      KEEP_BRANCH_REGEX: '^(main|master|develop|dev|release|staging|production|gh-pages)$'
      RUN_REF: ${{ github.ref_name }}

    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify GitHub CLI
        shell: bash
        run: |
          set -euo pipefail
          gh --version
          gh pr merge --help >/dev/null

      - name: Auto-merge eligible PRs (label-gated; enable auto-merge)
        shell: bash
        run: |
          set -euo pipefail

          case "${MERGE_METHOD}" in
            squash) merge_flag="--squash" ;;
            merge)  merge_flag="--merge" ;;
            rebase) merge_flag="--rebase" ;;
            *) echo "MERGE_METHOD must be squash|merge|rebase (got: ${MERGE_METHOD})" >&2; exit 1 ;;
          esac

          echo "Finding open PRs with label='${AUTOMERGE_LABEL}'..."
          mapfile -t prs < <(
            gh pr list \
              --state open \
              --label "${AUTOMERGE_LABEL}" \
              --limit 200 \
              --json number,isDraft,mergeable,baseRefName,title,url \
              --jq '.[] | "\(.number)\t\(.isDraft)\t\(.mergeable)\t\(.baseRefName)\t\(.title)\t\(.url)"'
          )

          if (( ${#prs[@]} == 0 )); then
            echo "No labeled open PRs found."
            exit 0
          fi

          for row in "${prs[@]}"; do
            IFS=$'\t' read -r pr_number is_draft mergeable base_ref title url <<< "${row}"

            if [[ "${INCLUDE_DRAFTS}" != "true" && "${is_draft}" == "true" ]]; then
              echo "Skipping draft PR #${pr_number}: ${title}"
              continue
            fi

            # mergeable can be: MERGEABLE, CONFLICTING, UNKNOWN (GitHub may report UNKNOWN transiently)
            if [[ "${mergeable}" == "CONFLICTING" ]]; then
              echo "Skipping PR #${pr_number} (conflicts): ${url}"
              continue
            fi

            echo "Processing PR #${pr_number} -> base=${base_ref} mergeable=${mergeable} method=${MERGE_METHOD} dry_run=${DRY_RUN}"
            echo "  ${title}"
            echo "  ${url}"

            if [[ "${DRY_RUN}" == "true" ]]; then
              echo "DRY RUN: would run: gh pr merge ${pr_number} ${merge_flag} --auto"
              echo "DRY RUN: (fallback) gh pr merge ${pr_number} ${merge_flag}"
              continue
            fi

            # Try to enable auto-merge first (preferred; respects branch protections/required checks).
            if output="$(gh pr merge "${pr_number}" ${merge_flag} --auto 2>&1)"; then
              echo "${output}"
              continue
            else
              echo "${output}"
            fi

            # If auto-merge can't be enabled due to missing branch protection, fallback to immediate merge.
            # (Still subject to GitHub permissions; consider removing fallback if you want strict protection.)
            if echo "${output}" | grep -qi "Protected branch rules not configured for this branch"; then
              echo "Auto-merge cannot be enabled (no branch protection). Attempting immediate merge for PR #${pr_number}..."
              if ! output2="$(gh pr merge "${pr_number}" ${merge_flag} 2>&1)"; then
                echo "${output2}"
                echo "WARN: Immediate merge failed for PR #${pr_number} (likely needs approvals/checks/conflict resolution)."
              else
                echo "${output2}"
              fi
            else
              echo "WARN: Could not enable auto-merge for PR #${pr_number} (likely missing checks/reviews, restrictions, or transient GitHub state)."
            fi
          done

      - name: "Cleanup: delete branches that are already merged"
        shell: bash
        run: |
          set -euo pipefail

          default_branch="$(gh api "repos/${GITHUB_REPOSITORY}" -q '.default_branch')"
          echo "Default branch: ${default_branch}"
          echo "Workflow running on ref: ${RUN_REF}"
          echo "DRY_RUN=${DRY_RUN}"

          git fetch origin --prune --tags
          git fetch origin "+refs/heads/*:refs/remotes/origin/*" --prune

          mapfile -t branches < <(gh api "repos/${GITHUB_REPOSITORY}/branches" --paginate -q '.[].name')

          if (( ${#branches[@]} == 0 )); then
            echo "No branches returned by GitHub API."
            exit 0
          fi

          for branch in "${branches[@]}"; do
            # Never delete default branch
            if [[ "${branch}" == "${default_branch}" ]]; then
              continue
            fi

            # Safety: don't delete the branch we're running from
            if [[ "${branch}" == "${RUN_REF}" ]]; then
              echo "Keeping branch (current workflow ref): ${branch}"
              continue
            fi

            # Never delete kept/protected branches
            if [[ "${branch}" =~ ${KEEP_BRANCH_REGEX} ]]; then
              echo "Keeping branch (matches KEEP_BRANCH_REGEX): ${branch}"
              continue
            fi

            # Don't delete branches with open PRs (limit=1 is enough)
            open_prs="$(gh pr list --state open --head "${branch}" --limit 1 --json number --jq 'length' || echo 0)"
            if [[ "${open_prs}" != "0" ]]; then
              echo "Keeping branch (has open PR): ${branch}"
              continue
            fi

            merged_by_pr="0"
            merged_by_git="0"

            # Only treat as merged if it merged into the default branch (limit=1 is enough)
            merged_prs="$(gh pr list --state merged --head "${branch}" --base "${default_branch}" --limit 1 --json number --jq 'length' || echo 0)"
            if [[ "${merged_prs}" != "0" ]]; then
              merged_by_pr="1"
            fi

            # Git ancestry check (handles merge commits / direct merges)
            if git show-ref --verify --quiet "refs/remotes/origin/${branch}"; then
              if git merge-base --is-ancestor "origin/${branch}" "origin/${default_branch}"; then
                merged_by_git="1"
              fi
            fi

            if [[ "${merged_by_pr}" == "1" || "${merged_by_git}" == "1" ]]; then
              if [[ "${DRY_RUN}" == "true" ]]; then
                echo "DRY RUN: would delete merged branch: ${branch}"
              else
                echo "Deleting merged branch: ${branch}"
                git push origin --delete "${branch}" || echo "WARN: Failed to delete ${branch} (protected or already deleted)."
              fi
            else
              echo "Not deleting (not detected as merged into ${default_branch}): ${branch}"
            fi
          done
